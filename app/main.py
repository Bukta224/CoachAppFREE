from __future__ import annotations

import os
import hmac
import hashlib
from datetime import date, datetime, timedelta
from typing import Optional, List

from fastapi import FastAPI, Request, Form, Depends, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse, PlainTextResponse
from fastapi.staticfiles import StaticFiles
from pydantic_settings import BaseSettings
from sqlalchemy import create_engine, String, Integer, Date, DateTime, ForeignKey, Text
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, Session, sessionmaker
from jinja2 import Environment, FileSystemLoader, select_autoescape


class Settings(BaseSettings):
    COACH_EMAIL: str = "coach@example.com"
    COACH_PASSWORD: str  # required (Render secret)
    APP_SECRET: str = "dev-secret-change-me"  # generated by Render
    SQLITE_PATH: str = "coachapp.sqlite"

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


settings = Settings()

DB_URL = f"sqlite:///{settings.SQLITE_PATH}"
engine = create_engine(DB_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

BASE_DIR = os.path.dirname(__file__)
jinja = Environment(
    loader=FileSystemLoader(os.path.join(BASE_DIR, "templates")),
    autoescape=select_autoescape(["html", "xml"]),
)

app = FastAPI(title="CoachApp")
app.mount("/static", StaticFiles(directory=os.path.join(BASE_DIR, "static")), name="static")


class Base(DeclarativeBase):
    pass


class Athlete(Base):
    __tablename__ = "athletes"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    name: Mapped[str] = mapped_column(String(120))
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    sessions: Mapped[List["PlanSession"]] = relationship(back_populates="athlete", cascade="all, delete-orphan")
    checkins: Mapped[List["DailyCheckin"]] = relationship(back_populates="athlete", cascade="all, delete-orphan")


class PlanSession(Base):
    __tablename__ = "plan_sessions"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    athlete_id: Mapped[int] = mapped_column(ForeignKey("athletes.id"), index=True)
    session_date: Mapped[date] = mapped_column(Date, index=True)
    type: Mapped[str] = mapped_column(String(20))  # road/track/gym
    title: Mapped[str] = mapped_column(String(200), default="")
    content: Mapped[str] = mapped_column(Text, default="")
    duration_min: Mapped[int] = mapped_column(Integer, default=60)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    athlete: Mapped["Athlete"] = relationship(back_populates="sessions")


class DailyCheckin(Base):
    __tablename__ = "daily_checkins"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    athlete_id: Mapped[int] = mapped_column(ForeignKey("athletes.id"), index=True)
    checkin_date: Mapped[date] = mapped_column(Date, index=True)
    sleep_h: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    hrv: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    rpe: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    asthma: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    note: Mapped[str] = mapped_column(Text, default="")
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    athlete: Mapped["Athlete"] = relationship(back_populates="checkins")


Base.metadata.create_all(engine)


def db() -> Session:
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()


def _sign(value: str) -> str:
    mac = hmac.new(settings.APP_SECRET.encode("utf-8"), value.encode("utf-8"), hashlib.sha256).hexdigest()
    return mac


def _cookie_value(email: str) -> str:
    return f"{email}|{_sign(email)}"


def _is_authed(request: Request) -> bool:
    token = request.cookies.get("coach_auth")
    if not token:
        return False
    parts = token.split("|", 1)
    if len(parts) != 2:
        return False
    email, sig = parts
    if email != settings.COACH_EMAIL:
        return False
    return hmac.compare_digest(sig, _sign(email))


def require_auth(request: Request):
    if not _is_authed(request):
        raise HTTPException(status_code=401, detail="Not authenticated")


@app.get("/", response_class=HTMLResponse)
def home(request: Request):
    if _is_authed(request):
        return RedirectResponse("/athletes", status_code=302)
    tpl = jinja.get_template("login.html")
    return HTMLResponse(tpl.render(error=None, coach_email=settings.COACH_EMAIL))


@app.post("/login")
def login(email: str = Form(...), password: str = Form(...)):
    # No bcrypt/passlib: avoids 72-byte issues entirely.
    if email != settings.COACH_EMAIL or password != settings.COACH_PASSWORD:
        tpl = jinja.get_template("login.html")
        return HTMLResponse(tpl.render(error="Hibás email vagy jelszó.", coach_email=settings.COACH_EMAIL), status_code=401)
    resp = RedirectResponse("/athletes", status_code=302)
    resp.set_cookie("coach_auth", _cookie_value(email), httponly=True, samesite="lax")
    return resp


@app.post("/logout")
def logout():
    resp = RedirectResponse("/", status_code=302)
    resp.delete_cookie("coach_auth")
    return resp


@app.get("/athletes", response_class=HTMLResponse, dependencies=[Depends(require_auth)])
def athletes(request: Request, session: Session = Depends(db)):
    athletes = session.query(Athlete).order_by(Athlete.created_at.desc()).all()
    tpl = jinja.get_template("athletes.html")
    return HTMLResponse(tpl.render(athletes=athletes))


@app.post("/athletes/create", dependencies=[Depends(require_auth)])
def athletes_create(name: str = Form(...), session: Session = Depends(db)):
    a = Athlete(name=name.strip())
    session.add(a)
    session.commit()
    return RedirectResponse("/athletes", status_code=302)


@app.get("/athletes/{athlete_id}", response_class=HTMLResponse, dependencies=[Depends(require_auth)])
def athlete_detail(athlete_id: int, request: Request, session: Session = Depends(db)):
    a = session.get(Athlete, athlete_id)
    if not a:
        raise HTTPException(404, "Athlete not found")
    today = date.today()
    week_start = today - timedelta(days=today.weekday())
    week_end = week_start + timedelta(days=6)

    sessions_q = (
        session.query(PlanSession)
        .filter(PlanSession.athlete_id == athlete_id)
        .filter(PlanSession.session_date >= week_start)
        .filter(PlanSession.session_date <= week_end)
        .order_by(PlanSession.session_date.asc(), PlanSession.type.asc())
        .all()
    )
    checkins_q = (
        session.query(DailyCheckin)
        .filter(DailyCheckin.athlete_id == athlete_id)
        .filter(DailyCheckin.checkin_date >= week_start)
        .filter(DailyCheckin.checkin_date <= week_end)
        .order_by(DailyCheckin.checkin_date.asc())
        .all()
    )
    checkin_by_date = {c.checkin_date: c for c in checkins_q}

    tpl = jinja.get_template("athlete_detail.html")
    return HTMLResponse(tpl.render(
        athlete=a,
        week_start=week_start,
        week_end=week_end,
        sessions=sessions_q,
        checkin_by_date=checkin_by_date,
        dates=[week_start + timedelta(days=i) for i in range(7)],
    ))


@app.post("/sessions/create", dependencies=[Depends(require_auth)])
def session_create(
    athlete_id: int = Form(...),
    session_date: str = Form(...),
    type: str = Form(...),
    title: str = Form(""),
    content: str = Form(""),
    duration_min: int = Form(60),
    session: Session = Depends(db),
):
    d = date.fromisoformat(session_date)
    ps = PlanSession(
        athlete_id=athlete_id,
        session_date=d,
        type=type,
        title=title.strip(),
        content=content.strip(),
        duration_min=int(duration_min),
    )
    session.add(ps)
    session.commit()
    return RedirectResponse(f"/athletes/{athlete_id}", status_code=302)


@app.post("/sessions/{session_id}/delete", dependencies=[Depends(require_auth)])
def session_delete(session_id: int, session: Session = Depends(db)):
    ps = session.get(PlanSession, session_id)
    if not ps:
        raise HTTPException(404)
    athlete_id = ps.athlete_id
    session.delete(ps)
    session.commit()
    return RedirectResponse(f"/athletes/{athlete_id}", status_code=302)


@app.post("/checkins/create", dependencies=[Depends(require_auth)])
def checkin_create(
    athlete_id: int = Form(...),
    checkin_date: str = Form(...),
    sleep_h: str = Form(""),
    hrv: str = Form(""),
    rpe: str = Form(""),
    asthma: str = Form(""),
    note: str = Form(""),
    session: Session = Depends(db),
):
    d = date.fromisoformat(checkin_date)

    def _int_or_none(x: str):
        x = x.strip()
        return int(x) if x else None

    c = session.query(DailyCheckin).filter_by(athlete_id=athlete_id, checkin_date=d).one_or_none()
    if not c:
        c = DailyCheckin(athlete_id=athlete_id, checkin_date=d)
        session.add(c)

    c.sleep_h = _int_or_none(sleep_h)
    c.hrv = _int_or_none(hrv)
    c.rpe = _int_or_none(rpe)
    c.asthma = _int_or_none(asthma)
    c.note = note.strip()
    session.commit()
    return RedirectResponse(f"/athletes/{athlete_id}", status_code=302)


def _zwo_escape(s: str) -> str:
    return (s or "").replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")


@app.get("/sessions/{session_id}/export.zwo", response_class=PlainTextResponse, dependencies=[Depends(require_auth)])
def export_zwo(session_id: int, session: Session = Depends(db)):
    ps = session.get(PlanSession, session_id)
    if not ps:
        raise HTTPException(404)

    title = ps.title or f"{ps.type} {ps.session_date.isoformat()}"
    descr = ps.content or ""

    warm = 600
    cool = 300
    main = max(300, int(ps.duration_min) * 60 - warm - cool)

    blocks = [
        ("Warmup", warm, 0.60, 0.75),
        ("Main", main, 0.70, 0.80),
        ("Cooldown", cool, 0.55, 0.65),
    ]

    zwo = f"""<?xml version="1.0" encoding="UTF-8"?>
<workout_file>
  <author>CoachApp</author>
  <name>{_zwo_escape(title)}</name>
  <description>{_zwo_escape(descr)}</description>
  <sportType>bike</sportType>
  <workout>
"""
    for name, dur, p1, p2 in blocks:
        zwo += f'    <SteadyState Duration="{dur}" PowerLow="{p1:.2f}" PowerHigh="{p2:.2f}"><textevent timeoffset="0" message="{_zwo_escape(name)}"/></SteadyState>\n'
    zwo += "  </workout>\n</workout_file>\n"
    return PlainTextResponse(zwo, media_type="application/xml")
